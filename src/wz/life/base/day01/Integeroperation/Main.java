package wz.life.base.day01.Integeroperation;

/**
 * @DESCRIPTION 整数运算
 * @AUTHOR: jamesbean
 * @DATE: 2020/9/25 11:37 上午
 */
public class Main {

    public static void main(String[] args) {

        //Java的整数运算遵循四则运算规则，
        // 可以使用任意嵌套的小括号。
        // 四则运算规则和初等数学一致。例如：

        int i = (100 + 200) * (99 - 88);
        int n = 7 * (5 + (i - 9));
        //3300
        System.out.println(i);
        //23072
        System.out.println(n);


        //整数的数值表示不但是精确的，
        // 而且整数运算永远是精确的，
        // 即使是除法也是精确的，
        // 因为两个整数相除只能得到结果的整数部分：
        int x = 12345 / 67;
        //184
        System.out.println(x);

        int y = 12345 % 67;
        // 12345÷67的余数是17
        System.out.println(y);

        //特别注意：整数的除法对于除数为0时运行时将报错，
        // 但编译不会报错。

        /**
         * 2.溢出
         */
        //要特别注意，整数由于存在范围限制，
        // 如果计算结果超出了范围，就会产生溢出，
        // 而溢出不会出错，却会得到一个奇怪的结果：
        int x1 = 2147483640;
        int y1 = 15;
        int sum = x1 + y1;
        // -2147483641
        System.out.println(sum);

        //要解释上述结果，我们把整数2147483640和15换成二进制做加法：

        /*0111 1111 1111 1111 1111 1111 1111 1000
        + 0000 0000 0000 0000 0000 0000 0000 1111
        -----------------------------------------
          1000 0000 0000 0000 0000 0000 0000 0111
        */
        //由于最高位计算结果为1，因此，加法结果变成了一个负数。

        //要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：

        long x2 = 2147483640;
        long y2 = 15;
        long sum2 = x2 + y2;
        // 2147483655
        System.out.println(sum2);


        //还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：
        // 3409, 相当于 n = n + 100;
        n += 100;
        // 3309, 相当于 n = n - 100;
        n -= 100;


        /**
         * 3.自增/自减
         */
        int n2 = 3300;
        n2++;
        n2--;
        int n3 = 100 + (++n2);
        //3401
        System.out.println(n3);
        //注意++写在前面和后面计算结果是不同的，
        // ++n表示先加1再引用n，n++表示先引用n再加1。
        // 不建议把++运算混入到常规运算中，
        // 容易自己把自己搞懵了。


        /**
         * 4.位移运算
         */

        /**
         * 5.位运算
         */

        /**
         * 6.类型自动提升与强制转型
         */



    }
}
